import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as p,c as n,a as o,b as d,e as r,f as i}from"./app-3e13ab12.js";const l={},m={href:"https://juejin.cn/post/7238153003282513957",target:"_blank",rel:"noopener noreferrer"},s={href:"https://vuejsnation.com/",target:"_blank",rel:"noopener noreferrer"};function u(f,e){const c=a("ExternalLinkIcon");return p(),n("div",null,[e[14]||(e[14]=o("h3",{id:"前言",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),d(" 前言")],-1)),o("p",null,[e[1]||(e[1]=o("code",null,"Vue3",-1)),e[2]||(e[2]=d("的")),e[3]||(e[3]=o("code",null,"Vapor Mode",-1)),e[4]||(e[4]=d("概念不知不觉已经提出来一年了，可以说是吊足了")),e[5]||(e[5]=o("code",null,"coder",-1)),e[6]||(e[6]=d("们的胃口，我去年的一篇莫名其妙成为爆款的文章")),o("a",m,[e[0]||(e[0]=d("🎉 尤雨溪为什么要推出 Vapor Mode🎉")),r(c)]),e[7]||(e[7]=d("中，我直观的展示了细粒度更新")),e[8]||(e[8]=o("code",null,"dom",-1)),e[9]||(e[9]=d("的优点，让大家历历在目！"))]),o("p",null,[e[11]||(e[11]=d("新的消息，2025 年 1 月 29 日至 30 日，将会举办")),e[12]||(e[12]=o("code",null,"Vue.js Nation Conference",-1)),e[13]||(e[13]=d("，详情你可以看这里：")),o("a",s,[e[10]||(e[10]=d("https://vuejsnation.com/")),r(c)])]),e[15]||(e[15]=i('<p>会议议题最值得关注的有两个：</p><ul><li><code>vue3.6</code> 功能预览</li><li><code>vapor mode</code> 的最新进展</li></ul><p>十分期待这次的会议，不过在了解<code>vapor mode</code>功能前。我们可以先了解下它解决了哪些问题。</p><h3 id="vapor-mode-将会解决的一些问题" tabindex="-1"><a class="header-anchor" href="#vapor-mode-将会解决的一些问题" aria-hidden="true">#</a> <code>Vapor Mode</code> 将会解决的一些问题</h3><h4 id="💎-重复的dom渲染" tabindex="-1"><a class="header-anchor" href="#💎-重复的dom渲染" aria-hidden="true">#</a> 💎 重复的<code>dom</code>渲染</h4><p>众所周知，<code>vue</code>的<code>view</code>模块被设计成以<code>template</code>对应的<code>render</code>函数为最小单元更新视图（也就是以组件为粒度更新），</p><p>所以在一些极端场景下，例如页面中有大量动态更新的节点时，<code>diff</code>计算仍然可能造成性能瓶颈，因为仍然会有不必要的<code>dom</code>渲染。</p><p>所以<code>vapor mode</code>的首要目标是解决各种场景的性能瓶颈。最好的方案是跳过虚拟<code>dom</code>，直接绑定数据到具体的<code>dom</code>节点，实现细粒度更新。</p><p>目前（虚拟<code>dom</code>版本）这么设计的原因并非无法实现以最小<code>dom</code>为粒度更新视图，而是以组件更新，可以较少复杂的<code>diff</code>计算。</p><p><code>vapor mode</code>让<code>vue</code>成为细粒度更新的框架，必然需要打破这一行为（放弃基于虚拟<code>dom</code>更新）！</p><p>目前所有的框架中，已经实现的将数据和具体<code>dom</code>节点绑定的框架有：<code>svelte 5</code>、<code>solidjs</code>、<code>angular 16</code>。</p><table><thead><tr><th>粒度</th><th>成员</th></tr></thead><tbody><tr><td>粗粒度</td><td><code>React</code></td></tr><tr><td>中粒度</td><td><code>Vue</code></td></tr><tr><td>细粒度</td><td><code>SolidJS</code>，<code>Svelte</code> <code>Angular 16</code></td></tr></tbody></table><p>而这些框架的无独有偶选择拥抱了<code>siganl</code>系统实现了数据和具体<code>dom</code>的绑定！</p><p>我们可以预见：<code>vue</code>在<code>3.x</code>大版本中，是不会放弃基于<code>proxy</code>的<code>reactivity</code>响应式系统的，</p><p>如果<code>vapor mode</code>在<code>3.x</code>大版本中发布，我们将会看到基于<code>reactivity</code>系统的数据和具体<code>dom</code>的绑定的方案。</p><h4 id="💎-耗时的运行时" tabindex="-1"><a class="header-anchor" href="#💎-耗时的运行时" aria-hidden="true">#</a> 💎 耗时的运行时</h4><p>还有一个问题，我们以前提到，<code>vue</code>虽然不像<code>react</code>一样重运行时，但是他的运行时，相对于<code>signal</code>系统的方案，还是偏长，</p><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/164cbb966d8048c9af430a209463ab5b~tplv-k3u1fbpfcp-watermark.image#?w=1422&amp;h=846&amp;s=27708&amp;e=png&amp;b=ffffff" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>这是因为<code>vue</code>的响应式系统虽然精准，但依赖追踪是在<code>运行时</code>动态绑定的，复杂应用中会出现过多的无用依赖，导致性能下降。</p><p>所以<code>vapor dode</code>将会引入静态依赖绑定，在<code>编译阶段</code>确定数据与副作用之间的关系，避免运行时依赖追踪的开销。</p><h4 id="💎-ssr性能与客户端hydration激活" tabindex="-1"><a class="header-anchor" href="#💎-ssr性能与客户端hydration激活" aria-hidden="true">#</a> 💎 <code>SSR</code>性能与客户端<code>Hydration</code>激活</h4><p>我们知道，服务器端渲染（SSR）功能是现代前端框架的重要特性，目前该功能的统一流程是：服务端渲染<code>SSR</code>生成静态的<code>html</code>片段，然后客户端<code>Hydration</code>激活，生成动态内容和事件绑定，</p><p>在激活时，先要进行一次服务端的静态<code>html</code>和客户端的虚拟<code>dom</code>对比，如果两者不一致，<code>Hydration </code>会丢弃服务端的<code>HTML</code>，重新生成客户端的<code>DOM</code>，这部分也会消耗性能，所以仍存在性能优化空间。</p><p>前面说过<code>vapor dode</code>将会引入静态依赖绑定，这样的话在理论上不需要<code>html</code>和客户端的虚拟<code>dom</code>的对比了。</p><h3 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h3><p>如果<code>vapor mode</code>如上所说，放弃了基于<code>dom</code>的更新方案，尽管性能得到了提升，但是也会面临新的挑战：</p><p>首先，开发者需要理解信号系统的基本原理，习惯以细粒度更新方式思考组件的概念了。</p><p>其次，另外<code>vapor mode</code>的引入可能使现有的<code>vue</code>工具链（如 <code>Vue DevTools</code>、插件生态）发生翻天覆地的变化。</p><p>另外，<code>vue</code>的<code>vapor mode</code>可能会和<code>angular</code>一样，同时保留旧的虚拟<code>DOM</code>渲染模式和新的细粒度渲染模式，</p><p>所以，希望每个开发者可以在特定场景中选择性的使用<code>Vapor Mode</code>，无需大规模重构现有项目，从而实现性能和开发体验的最佳平衡！</p><p>无论如何，<code>vapor mode</code>的发布将会推动前端框架在高性能和易用性之间找到新的平衡点，让我们拭目以待吧！！！</p><p>如果你觉得这篇文章不错，可以关注同步更新最新文章的公众号：萌萌哒草头将军</p><p>如果文章中，存在纰漏，欢迎指正！</p>',33))])}const b=t(l,[["render",u],["__file","🚀🚀🚀Vapor Mode发布前，你应该知道的一些事情.html.vue"]]);export{b as default};
