import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as d,c as s,f as p,a,b as t,e as i}from"./app-bea6ff1b.js";const l={},c={href:"https://juejin.cn/post/7226689042406637624",target:"_blank",rel:"noopener noreferrer"},h={href:"https://juejin.cn/post/7226689042406637624",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/7235628080219078693",target:"_blank",rel:"noopener noreferrer"},f={href:"https://juejin.cn/post/7236719086049837093",target:"_blank",rel:"noopener noreferrer"},v={href:"https://juejin.cn/post/7238153003282513957",target:"_blank",rel:"noopener noreferrer"};function S(b,e){const r=o("ExternalLinkIcon");return d(),s("div",null,[e[6]||(e[6]=p('<blockquote><p>文章首发公众号：萌萌哒草头将军，最近关注有🎁</p></blockquote><h3 id="💎-只有运行时的javascript" tabindex="-1"><a class="header-anchor" href="#💎-只有运行时的javascript" aria-hidden="true">#</a> 💎 只有运行时的JavaScript</h3><p>JavaScript从诞生至今，都是运行在浏览器环境或者V8环境的编程语言，由于它边解释边执行的特性，导致只有运行时，没有编译时。</p><blockquote><p>这个表述是有争论的，可以理解为JavaScript的运行时和编译时是交织在一起的，这就是边解释边执行的含义。</p></blockquote><p>大多数的编程语言，需要将代码转为二进制字节码文件，然后才能被系统识别并运行，转码的过程就是编译时。所以很多编程语言都需要提供转码模块。比如Java使用虚拟机编辑成目标机器字节码，Python有Brython等多种编译器编译代码为字节码</p><p>早期，JavaScript从诞生的很长一段时间里，仅仅被用来和服务器通信的工具，随着<code>ajax</code>的出现，用户可以在不刷新页面的情况下和服务端交互。再后来，<code>Jquery</code>兴起，使我们可以快速进行JavaScript和dom的交互。此时，JavaScript一直都是只有运行时的状态。</p><h3 id="💎-只有编译时的typescript" tabindex="-1"><a class="header-anchor" href="#💎-只有编译时的typescript" aria-hidden="true">#</a> 💎 只有编译时的TypeScript</h3><p>只有运行时的语言，最大的缺点就是代码里的错误只能在运行时抛出异常。这也就是为什么会出现<code>TypeScript</code>，因为所有的ts文件先被编译成js文件，然后才会被运行在模板机器中，此时代码里的错误在编译阶段就可以抛出异常了。</p><p>不过<code>TypeScript</code>仅仅拥有编译时，因为编译成js文件后就是JavaScript的势力圈了。</p><p>随着前端的框架的出现，引入了模板语法和Jsx的概念，才让JavaScript拥有了编译时，不过，这么说不严谨，因为这种编译时，是将基于前端框架的编译时：将框架模板或者Jsx编译成JavaScript代码的过程。</p><blockquote><p>这里的模板是指基于JavaScript的解析的模板，Jsp、Thinkphp、Thymeleaf等模板是基于后端语言的模板。</p></blockquote><h3 id="💎-编译时也有饭圈" tabindex="-1"><a class="header-anchor" href="#💎-编译时也有饭圈" aria-hidden="true">#</a> 💎 编译时也有饭圈</h3><p>编译时的概念被分为即时编译（JIT）和预编译（AOT）：</p><ul><li>即时编译（JIT）：Just In Time，在宿主环境中边编译边执行</li><li>预编译（AOT）：Ahead Of Time，编译完成之后在宿主环境中执行</li></ul><p>Angular的编译器同时提供了两种编译方案，不过现在已经凉透了，再次上香！！！</p>',15)),a("p",null,[e[1]||(e[1]=t("第一次上香是在这篇文章里：")),a("a",c,[e[0]||(e[0]=t("🔥超级简单的Svelte，学不会你来打我")),i(r)])]),e[7]||(e[7]=p('<p>AOT的好处是可以拥有更短的运行时间，<br> 大多数框架都采用了AOT编译技术，因为预编译（AOT）的特点，采用AOT编译技术的框架，可以对开发者的代码做充分的分析，从而有更大的优化空间。</p><p>总体来看，目前前端框架的AOT方案有两种：</p><ul><li>Jsx</li><li>模板语法</li></ul><h3 id="💎-运行时-vs-编译时-前端框架的选择" tabindex="-1"><a class="header-anchor" href="#💎-运行时-vs-编译时-前端框架的选择" aria-hidden="true">#</a> 💎 运行时 VS 编译时，前端框架的选择</h3><p>前端框架都是在编译时，完成代码的转换，在运行时完成编译结果的渲染。但是由于每个框架的策略不同，导致花在运行时和编译时的时间有所不同。</p><h4 id="重运行时的react" tabindex="-1"><a class="header-anchor" href="#重运行时的react" aria-hidden="true">#</a> 重运行时的React</h4><p>React采用Jsx方案编译，由于Jsx语法过于灵活，导致在编译时，React可以做的优化有限，所以，React将很多工作放在了运行时阶段。</p><h4 id="重编译时的solidjs和svelte" tabindex="-1"><a class="header-anchor" href="#重编译时的solidjs和svelte" aria-hidden="true">#</a> 重编译时的SolidJS和Svelte</h4><p>SolidJS也采用了Jsx做AOT编译，不过，为了可以直接编译出可执行的JavaScript代码片段，选择对Jsx的灵活的语法做了限制。比如提供Show标签代替if语法，使用For标签代替for语法等。从而让它可以在编译时完成大量的工作。</p><p>Svelte和Vue都采用了模板语法方案做AOT编译，不过Vue的模板语法是基于HTML的，而Svelte的模板语法是基于JavaScript的，这就导致了Svete可以直接编译出JavaScript代码片段，从而减少运行时的时间。</p><h4 id="平衡大师vue" tabindex="-1"><a class="header-anchor" href="#平衡大师vue" aria-hidden="true">#</a> 平衡大师Vue</h4><p>而Vue编译之后的结果是不可运行的Vnode，在运行时，需要像React一样，解析编译结果为JavaScript代码，然后再目标环境运行代码。</p><h3 id="🎉-总结" tabindex="-1"><a class="header-anchor" href="#🎉-总结" aria-hidden="true">#</a> 🎉 总结</h3><p>我根据SolidJS官网给的排名，绘制了编译时到运行时，代码成为可执行JavaScript的示意图图如下：</p><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/164cbb966d8048c9af430a209463ab5b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>所以你觉得是运行时的框架好还是编译时的框架好了？</p><p>最后，希望大家理性看待这个问题，框架之间”卷“起来，对我们开发者来说是好事，</p><p>附上犹大的推特照片：</p><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539c0c5d2d2847dfad284c333fcf066b~tplv-k3u1fbpfcp-watermark.image?" alt="尤雨溪和Dan合影" tabindex="0" loading="lazy"><figcaption>尤雨溪和Dan合影</figcaption></figure><h3 id="💡-精彩文章回顾" tabindex="-1"><a class="header-anchor" href="#💡-精彩文章回顾" aria-hidden="true">#</a> 💡 精彩文章回顾</h3>',20)),a("p",null,[a("a",h,[e[2]||(e[2]=t("🔥超级简单的Svelte，学不会你来打我")),i(r)])]),a("p",null,[a("a",u,[e[3]||(e[3]=t("🚀Svelte原理和进阶看这篇就够了🚀")),i(r)])]),a("p",null,[a("a",f,[e[4]||(e[4]=t("学不完的框架，🐔啄不完的米，SolidJS，你到底爱谁？😘")),i(r)])]),a("p",null,[a("a",v,[e[5]||(e[5]=t("🎉尤雨溪为什么要推出Vapor Mode🎉")),i(r)])])])}const g=n(l,[["render",S],["__file","运行时💎？还是编译时🚀？前端框架的角斗场.html.vue"]]);export{g as default};
